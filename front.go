package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"

	"github.com/ethereum/go-ethereum/common/compiler"
	"github.com/olliephillips/front/abi2js"
)

var (
	addrFlag  = flag.String("address", "", "Address of existing contract/contracts")
	asyncFlag = flag.Bool("async", false, "Use asynchronous callbacks in with state changing functions")
	abiFlag   = flag.String("abi", "", "Path to the Ethereum contract ABI json to convert")
	solFlag   = flag.String("sol", "", "Path to the Ethereum contract Solidity source to build and convert")
	solcFlag  = flag.String("solc", "solc", "Solidity compiler to use if source builds are requested")
	outFlag   = flag.String("out", "", "Output file for the generated web3.js javascript (default = stdout)")
)

func main() {
	var code string

	// get flags
	flag.Parse()

	// check options
	if *abiFlag == "" && *solFlag == "" {
		fmt.Printf("No contract ABI (--abi) or Solidity source (--sol) specified\n")
		os.Exit(-1)
	} else if *abiFlag != "" && *solFlag != "" {
		fmt.Printf("Use either Contract ABI (--abi) or Solidity source (--sol) flag\n")
		os.Exit(-1)
	}

	var abis []string
	var byteCode []string
	var contractName []string

	if *solFlag != "" {
		// compile the solidity
		contracts, err := compiler.CompileSolidity(*solcFlag, *solFlag)
		if err != nil {
			fmt.Printf("Failed to build Solidity contract: %v\n", err)
			os.Exit(-1)
		}
		// gather contract json post build
		for name, contract := range contracts {
			goodname := strings.Split(name, ":")
			abi, _ := json.Marshal(contract.Info.AbiDefinition)
			abis = append(abis, string(abi))
			byteCode = append(byteCode, contract.Code)
			contractName = append(contractName, goodname[1])
		}
	} else {
		// load from ABI
		abi, err := ioutil.ReadFile(*abiFlag)
		if err != nil {
			fmt.Printf("Failed to read input ABI: %v\n", err)
			os.Exit(-1)
		}
		abis = append(abis, string(abi))

		// use filename for contract name
		contractName = append(contractName, getFilename(*abiFlag))
	}

	var js string

	// include web3 initialisation
	js += abi2js.InitWeb3()

	// include ABIs into javascript
	for i := range abis {
		js += abi2js.IncludeABI(contractName[i], abis[i])
	}

	// include bytecode if address not provided will be used to construct
	if *addrFlag == "" {
		for i := range abis {
			js += abi2js.IncludeByteCode(contractName[i], byteCode[i])
		}
	}

	// generate web3.js methods by passing each abi in turn
	for i := range abis {
		converted, err := abi2js.Convert(contractName[i], abis[i], asyncFlag, addrFlag)
		if err != nil {
			fmt.Printf("Failed to convert ABI to JavaScript: %v\n", err)
			os.Exit(-1)
		}
		// good, add to js payload
		js += converted
	}
	code = js

	// comment wrap everything
	startComment := `
/********** boilerplate starts here ************
`
	endComment := `

********** boilerplate ends here **************/
`
	code = startComment + code + endComment

	// preprend credit/warning
	code = makeCredit() + code

	// output
	if *outFlag == "" {
		fmt.Printf("%s\n", code)
		return
	}
	if err := ioutil.WriteFile(*outFlag, []byte(code), 0600); err != nil {
		fmt.Printf("Failed to write Web3 JavaScript: %v\n", err)
		os.Exit(-1)
	}

}

func getFilename(p string) string {
	// helper for extracting filename
	p = path.Base(p)
	n := strings.LastIndexByte(p, '.')
	if n > 0 {
		return p[:n]
	}
	return p
}

func makeCredit() string {
	warning := `
/** 
 ** Code generated - manual changes may be lost if regenerated
 ** Generated by Front a solc/abi to web3 javascript converter
 ** Project page: http://github.com/olliephillips/front
**/
`
	return warning
}
